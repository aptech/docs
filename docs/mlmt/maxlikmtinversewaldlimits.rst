maxlikmtInverseWaldLimits
==============================================

Purpose
----------------

Computes confidence limits by inversion of the Wald statistic.

Format
----------------
.. function:: out1 = maxlikmtInverseWaldLimits(out0, c0)
                  out1 = maxlikmtInverseWaldLimits(out0)

    :param out0: Instance of :class:`maxlikmtResults` structure containing results of an estimation generated by a call to :func:`maxlikmt`.
    :type out0: struct

    :param c0: Optional instance of the :class:`maxlikmtControl` structure used in the call to :func:`maxlikmt`` that produced the results in out0.
    :type c0: struct

    :return: An instance of :class:`maxlikmtResults` structure that is a duplicate of out0 except that the member, out1.profileLimits have been set to the confidence limits by inversion of the Wald statistic.
    :rtype: struct

Example
-------

The following is a complete example demonstrating the use of :func:`maxlikmtInverseWaldLimits`:

::

    // Load maxlikmt library
    library maxlikmt;
    
    /*
    ** Objective function
    */
    proc lpr(struct PV p, x, y, ind);
        local s2, b0, b, yh, u, res, g1, g2;
        
        // Declare 'mm' to be a modelResults struct
        // to hold the function and gradient values
        struct modelResults mm;
    
        // Extract parameters from PV struct
        b0 = pvUnpack(p, "b0");
        b = pvUnpack(p, "b");
        s2 = pvUnpack(p, "variance");
    
        // Computations shared between function and gradient
        yh = b0 + x * b;
        res = y - yh;
        u = y[.,1] ./= 0;
    
        // Compute function value
        if ind[1];
            mm.function = u.*lnpdfmvn(res, s2) + (1-u).*(ln(cdfnc(yh/sqrt(s2))));
        endif;
    
        // Compute gradient if second element
        // of 'ind' is nonzero
        if ind[2];
            yh = yh/sqrt(s2);
            g1 = ((res~x.*res)/s2)~((res.*res/s2)-1)/(2*s2);
            g2 = (-(ones(rows(x), 1)~x)/sqrt(s2))~(yh/(2*s2));
            g2 = (pdfn(yh)./cdfnc(yh)).*g2;
            mm.gradient = u.*g1 + (1-u).*g2;
        endif;
    
        retp(mm);
    
    endp;
    
    struct PV p0;
    p0 = pvPack(pvCreate, 1, "b0");
    p0 = pvPack(p0, 1|1|1, "b");
    p0 = pvPack(p0, 1, "variance");
    
    // Declare maxlikmtControl structure 
    struct maxlikmtControl c0;
    c0 = maxlikmtControlCreate;
    
    // Set title 
    c0.title = "Tobit Example";
    
    // Set parameter bounds
    c0.Bounds = {
        -10 10,
        -10 10,
        -10 10,
        -10 10,
        .1 10
    };
    

    // Load tobit data
    z = loadd("maxlikmttobit");
    
    // Separate x and y 
    y = z[., 1];
    x = z[., 2:4];
    
    // Declare instance of maxlikmtResults structure
    struct maxlikmtResults out1;
    out1 = maxlikmt(&lpr, p0, x, y, c0);
    
    // Limits by inversion of likelihood ratio statistic
    out1 = maxlikmtProfileLimits(&lpr, out1, x, y, c0);
    
    // Limits by inversion of Wald statistic
    out1 = maxlikmtInverseWaldLimits(out1, c0);
    
    // Print results
    call maxlikmtPrt(out1);
