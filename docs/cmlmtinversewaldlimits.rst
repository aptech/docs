cmlmtInverseWaldLimits
==============================================

Purpose
----------------

Computes confidence limits by inversion of the Wald statistic.

Format
----------------
.. function:: out = cmlmtInverseWaldLimits(out0, c0)
                  out = cmlmtInverseWaldLimits(out0)

    :param out0: Instance of :class:`cmlmtResults` structure containing results of an estimation generated by a call to :func:`cmlmt`.
    :type out0: struct

    :param c1: Optional input. Instance of a :class:`cmlmtControl` structure containing the following members:

        .. include:: include/cmlmtcontrolstruct.rst

    :type c1: struct

    :return out: An instance of a :class:`cmlmtResults` structure. Contains the results of the optimization problem, including parameter estimates, function evaluations, and various statistical measures.

        .. include:: include/cmlmtresultsstruct.rst

    :rtype out: struct

Example
-------

The following is a complete example demonstrating the use of :func:`cmlmtInverseWaldLimits`:

::

    // Load cmlmt library
    library cmlmt;
    
    // Likelihood function 
    proc lpr(struct PV p, x, y, ind);
        local s2, b0, b, yh, u, res, g1, g2;
        
        // Declare 'mm' to be a modelResults struct
        // to hold the function and gradient values
        struct modelResults mm;
    
        // Extract parameters from PV struct
        b0 = pvUnpack(p, "b0");
        b = pvUnpack(p, "b");
        s2 = pvUnpack(p, "variance");
    
        // Computations shared between function and gradient
        yh = b0 + x * b;
        res = y - yh;
        u = y[.,1] ./= 0;
    
        // Compute function value
        if ind[1];
            mm.function = u.*lnpdfmvn(res, s2) + (1-u).*(ln(cdfnc(yh/sqrt(s2))));
        endif;
    
        // Compute gradient if second element
        // of 'ind' is nonzero
        if ind[2];
            yh = yh/sqrt(s2);
            g1 = ((res~x.*res)/s2)~((res.*res/s2)-1)/(2*s2);
            g2 = (-(ones(rows(x), 1)~x)/sqrt(s2))~(yh/(2*s2));
            g2 = (pdfn(yh)./cdfnc(yh)).*g2;
            mm.gradient = u.*g1 + (1-u).*g2;
        endif;
    
        retp(mm);
    
    endp;
    
    struct PV p0;
    p0 = pvPack(pvCreate, 1, "b0");
    p0 = pvPack(p0, 1|1|1, "b");
    p0 = pvPack(p0, 1, "variance");
    
    // Declare cmlmtControl structure 
    struct cmlmtControl c0;
    c0 = cmlmtControlCreate;
    
    // Set title 
    c0.title = "Tobit Example";
    
    // Set parameter bounds
    c0.Bounds = {
        -10 10,
        -10 10,
        -10 10,
        -10 10,
        .1 10
    };
    

    // Load tobit data
    z = loadd(getGAUSSHome("pkgs/cmlmt/examples/cmlmttobit.dat"));
    
    // Separate x and y 
    y = z[., 1];
    x = z[., 2:4];
    
    // Declare instance of cmlmtResults structure
    struct cmlmtResults out1;
    out1 = cmlmt(&lpr, p0, x, y, c0);
    
    // Limits by inversion of likelihood ratio statistic
    out1 = cmlmtProfileLimits(&lpr, out1, x, y, c0);
    
    // Limits by inversion of Wald statistic
    out1 = cmlmtInverseWaldLimits(out1, c0);
    
    // Print results
    call cmlmtPrt(out1);
